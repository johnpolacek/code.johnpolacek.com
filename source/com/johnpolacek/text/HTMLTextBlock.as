package com.johnpolacek.text{		import flash.display.Bitmap;	import flash.display.BlendMode;	import flash.display.Loader;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.TimerEvent;	import flash.text.AntiAliasType;	import flash.text.Font;	import flash.text.StyleSheet;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;	import flash.utils.Timer;	/** * The HTMLTextBlock class displays html text and manages * the use of StyleSheets and inline images *  * @example  * <br /> * Create a text block containing the string "txt" that is * 500 pixels wide and is styled using the StyleSheet "ss": * <code> * htmlTextBlock = new HTMLTextBlock(txt, 500, ss); * </code> * <br/> * Change the width of the HTMLTextBlock to 300: * <code> * htmlTextBlock.setWidth(300); * </code> * * @version  * <b>27 Apr 2010</b>  Improved inline image alignment <br>  * <b>5 Apr 2010</b>   * @author John Polacek, john@johnpolacek.com */	 			public class HTMLTextBlock extends Sprite {				public static const IMG_HSPACE:int = 8;		public static const IMG_VSPACE:int = 2;				/** Contains the text. **/		public var textfield:TextField = new TextField();		/** Width of the textfield. Default 0 (autosized). **/		public var blockWidth:int;				private var delay:Timer;		private var hasInlineImage:Boolean = false;		private var inlineImage:Bitmap;						/** 		* @param txt The html text string		* @param w   The width of the HTMLTextBlock. Default 0 (autosized)		* @param ss  The StyleSheet used to style the htmlText. Default null (no styling)		* @param oX  Offsets the x coordinate of the textfield. Default 0		* @param oYX  Offsets the y coordinate of the textfield. Default 0		**/		public function HTMLTextBlock(txt:String, 									  w:int = 0, 									  ss:StyleSheet = null) 		{			blockWidth = w;			var doEmbedFonts:Boolean = (ss != null);			if (blockWidth != 0)			{				textfield.width = blockWidth;			}			else				textfield.width = 960;						if (ss)				textfield.styleSheet = ss;						textfield.blendMode = BlendMode.LAYER;			textfield.autoSize = TextFieldAutoSize.LEFT;			textfield.wordWrap = true;			textfield.multiline = true;			textfield.antiAliasType = AntiAliasType.ADVANCED;			textfield.htmlText = processHTMLText(txt);			textfield.embedFonts = doEmbedFonts;						addChild(textfield);						if (hasInlineImage) 			{				var loader:Loader = textfield.getImageReference("image") as Loader;				if(loader)				{					loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler, false, 0, true);				}				textfield.addEventListener(Event.CHANGE, onHTMLImageLoaded, false, 0, true); //Listens for when the textfield is resized by html images			} 			else 			{				//If no images, dispatch complete event with small delay to allow listeners to register				delay = new Timer(10, 1);				delay.addEventListener(TimerEvent.TIMER, delayHandler, false, 0, true);				delay.start();				function delayHandler(event:TimerEvent) 				{					delay.removeEventListener(TimerEvent.TIMER, delayHandler);					onLoadComplete();				}			}					}				private function ioErrorHandler(event:Event):void 		{			trace("HTMLTextBlock Error Handler: "+event);			onLoadComplete();		}				private function onHTMLImageLoaded(event:Event):void 		{			textfield.removeEventListener(Event.CHANGE, onHTMLImageLoaded);			inlineImage = Bitmap(event.target.getImageReference("image").content);			inlineImage.smoothing = true;			inlineImage.x -= 8;  // offsets hspace attribute in img tag so image is properly aligned to textfield			onLoadComplete();		}				/** Width of the textfield. Default 0 (autosized). **/		public function onLoadComplete():void 		{			setWidth(blockWidth);			dispatchEvent(new Event(Event.COMPLETE)); 		}				/** Sets width of TextBlock **/		public function setWidth(w:int):void 		{			blockWidth = w;			textfield.autoSize = TextFieldAutoSize.LEFT;			if (blockWidth == 0)			{				textfield.width = textfield.textWidth + 5;				if (inlineImage && textfield.textWidth < inlineImage.width)				{					textfield.width = inlineImage.width + IMG_HSPACE;					this.width = this.width; // fixes bug where flash doesn't properly read width				}			}			else			{				textfield.width = blockWidth + IMG_HSPACE;			}			var heightAdjust:int = textfield.textHeight;			if (heightAdjust < textfield.height)				heightAdjust = textfield.height;			heightAdjust += (IMG_VSPACE * 2) + 1;			textfield.autoSize = TextFieldAutoSize.NONE; // turning off autoSize fixes bug where Mouse scrolling causes text to scroll			textfield.height = heightAdjust;		}				private function processHTMLText(htmlText:String):String 		{			// REMOVE CDATA WRAPPER			//			if (htmlText.indexOf("![CDATA[")!=-1) 			{				htmlText = htmlText.replace("![CDATA[","");  //"![CDATA["+htmlText+"]]";				htmlText = htmlText.replace("]]","");			}						// ADD BODY TAG IF MISSING			//			if (htmlText.indexOf("<body>")==-1) 			{				htmlText = "<body>"+htmlText+"</body>";			}						// MODIFY <u> tags for underlining			//			while (htmlText.indexOf("<u>")!=-1) 			{				htmlText = htmlText.replace('<u>','<span class="underline">');				htmlText = htmlText.replace('</u>','</span>');			}						while (htmlText.indexOf("<sup>")!=-1) 			{				htmlText = htmlText.replace('<sup>','<span class="sup">');				htmlText = htmlText.replace('</sup>','</span>');			}						while (htmlText.indexOf("<sub>")!=-1) 			{				htmlText = htmlText.replace('<sub>','<span class="sub">');				htmlText = htmlText.replace('</sub>','</span>');			}									// MODIFY IMG TAGS			//			if (htmlText.indexOf("<img src")!=-1) 			{				var imgTagIndex:int = htmlText.indexOf("<img src");				var imgTagEndIndex:int = htmlText.indexOf("/>",imgTagIndex);				var imgTag:String = htmlText.slice(imgTagIndex,imgTagEndIndex);				var imgTagAttributes:String = 'hspace="'+IMG_HSPACE+'" vspace="'+IMG_VSPACE+'" id="image" ';				var imgTagMod:String = imgTag + imgTagAttributes;				htmlText = htmlText.replace(imgTag,imgTagMod);						hasInlineImage = true;			} 						// Note: condenseWhite = true doesn't produce reliable results, 			// so RegExp/Replace is necessary for formatting						var tabs:RegExp = /\t/g;			htmlText = htmlText.replace(tabs, "");						var newlineAfterTag:RegExp = />\n/g;			htmlText = htmlText.replace(newlineAfterTag, ">");						var extraCommaSpace:RegExp = />\n\s\s,/g;			var extraPeriodSpace:RegExp = />\n\s\s\./g;						htmlText = htmlText.replace(extraCommaSpace, ">,");			htmlText = htmlText.replace(extraPeriodSpace, ">.");						return htmlText;		}	}}