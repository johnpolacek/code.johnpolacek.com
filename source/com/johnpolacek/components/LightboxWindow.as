package com.johnpolacek.components {	import flash.display.BlendMode;	import flash.display.Shape;	import flash.display.Sprite;	import flash.text.AntiAliasType;	import flash.text.Font;	import flash.text.TextFormat;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.filters.BitmapFilter;	import flash.filters.BitmapFilterQuality;	import flash.filters.DropShadowFilter;	import com.greensock.TweenLite;	import com.greensock.easing.Expo;	import com.johnpolacek.components.LightboxContentInfo;	import com.johnpolacek.display.AudioDisplay;	import com.johnpolacek.display.ContentDisplay;	import com.johnpolacek.display.ContentDisplayCreator;	import com.johnpolacek.shapes.ArrowHead;	import com.johnpolacek.shapes.EllipseShape;	import com.johnpolacek.shapes.RectangleShape;	import com.johnpolacek.utils.DisplayUtils;/** * The LightboxWindow class contains the ContentDisplay sprite.  * Uses the ContentDisplayCreator simple Factory to generate content containers *  * @sends new Event(LIGHTBOX_PREV) # When prevButton is clicked.  * @sends new Event(LIGHTBOX_NEXT) # When prevButton is clicked.  * * @see com.johnpolacek.display.ContentDisplayCreator * @see com.johnpolacek.display.ContentDisplay * @author John Polacek, john@johnpolacek.com */	 	public class LightboxWindow extends Sprite 	{		/**  Event constant for transitioning to next ContentDisplay in the content group **/		public static const LIGHTBOX_NEXT:String = "lightboxNext";		/**  Event constant for transitioning to prev ContentDisplay in the content group **/		public static const LIGHTBOX_PREV:String = "lightboxPrev";		/**  Constant for build transitionStyle **/		public static const TRANSITION_BUILD = "transitionBuild";		/**  Constant for fly in right transitionStyle  **/		public static const TRANSITION_FLY_IN_RIGHT = "transitionFlyInRight";		/**  Constant for fly in left transitionStyle  **/		public static const TRANSITION_FLY_IN_LEFT = "transitionFlyInLeft";		/**  Determines which style is used for transitions in and out  **/		public var transitionStyle:String = TRANSITION_BUILD;		/**  The content info object corresponding to the content in the window  **/		public var contentInfo:LightboxContentInfo;		/**  Maximum width of content, in pixels.  **/		public var maxContentWidth:int = 9999;		/**  Maximum height of content, in pixels.  **/		public var maxContentHeight:int = 9999;				private var contentBackground:Sprite;		private var descriptionText:Sprite;				private var content:ContentDisplay;		private var closeButton:Sprite;		private var nextButton:Sprite;		private var prevButton:Sprite;		private var navButtonField:TextField		private var contentCreator:ContentDisplayCreator;		private var format:LightboxFormat;		private var currElement:int = 0;		private var totalElements:int = 0;						/** 		* @param f The LightboxFormat object that holds all styling info. If null, default styling is used.		**/		public function LightboxWindow (f:LightboxFormat = null) 		{			format = f ? f : new LightboxFormat(); 			this.blendMode = BlendMode.LAYER;			contentCreator = new ContentDisplayCreator();  // Simple Factory class that returns ContentDisplay sprite			this.visible = false;		}				/** 		* Loads and displays content.		* @param contentURL Filepath to the content		* @param tText Text that will appear in the title field of the content window. Default is ""		* @param stText Text that will appear in the subtitle field of the content window. Default is ""		* @param nText Text that will appear in the note field of the content window. Default is ""		* @param contentInfo Object that holds additional values for content. Default is null		**/		public function displayContent(c:LightboxContentInfo):void		{			contentInfo = c;			content = contentCreator.create(contentInfo.url, contentInfo);			content.addEventListener(Event.COMPLETE, onContentLoadComplete);			content.addEventListener(IOErrorEvent.IO_ERROR, onIOError);						if (!content) 				trace("Error: Could not initialize content:"+contentInfo.url);						descriptionText = createDescriptionText();		}				/**  Initiates content window close transition. **/		public function close():void		{			transitionOut();			content.removeEventListener(Event.COMPLETE, onContentLoadComplete);		}		//--------------------------------------------------------------------------    //    //  Object Creation    //    //--------------------------------------------------------------------------			private function build():void		{			trace("LightboxWindow.build");			var maxWindowHeight:int = maxContentHeight - descriptionText.height - (format.buttonSize * 3);			if (content.height > maxContentHeight || content.width > maxContentWidth)				DisplayUtils.scaleToFit(content, maxContentWidth, maxWindowHeight);			contentBackground = createBackground();			content.x -= content.width/2;			content.y -= (content.height + descriptionText.height)/2;			descriptionText.x = content.x;			descriptionText.y = content.y + content.height;			closeButton = createCloseButton();			closeButton.x = content.x + contentBackground.width - format.margin - closeButton.width;			closeButton.y = content.y - closeButton.height - format.margin;			addChild(closeButton);			addChild(contentBackground);			addChild(content);			addChild(descriptionText);			if (contentInfo.linkText != "")			{				var linkTextField:TextField = createLinkText();				linkTextField.x = content.x + content.width - linkTextField.textWidth - 4;				linkTextField.y = content.y + content.height - linkTextField.textHeight - 4;				addChild(linkTextField);			}			if (currElement > 0 && totalElements > 0)			{				nextButton = createNavButton();				nextButton.x = contentBackground.width/2 - nextButton.width - 2;				nextButton.y = contentBackground.height/2 + 6;				addChildAt(nextButton, 0);									navButtonField = new TextField();				var navButtonFormat:TextFormat = format.navTextFormat;				navButtonField.antiAliasType = AntiAliasType.ADVANCED;				navButtonField.autoSize = TextFieldAutoSize.LEFT;				navButtonField.text = currElement + " of " + totalElements;				navButtonField.x = nextButton.x - navButtonField.textWidth - nextButton.width + format.navTextX;				navButtonField.y = nextButton.y + format.navTextY;				if (format.subtitleTextFormat.font != null) 					navButtonField.embedFonts = true;				navButtonField.setTextFormat(navButtonFormat);				navButtonField.blendMode = BlendMode.LAYER;				addChild(navButtonField);								prevButton = createNavButton();				prevButton.scaleX = -1;				prevButton.x = navButtonField.x - nextButton.width/2 + 2;				prevButton.y = nextButton.y;				addChildAt(prevButton, 0);								nextButton.addEventListener(MouseEvent.CLICK, onNextClick);				prevButton.addEventListener(MouseEvent.CLICK, onPrevClick);				TweenLite.from(prevButton, .25, {x:prevButton.x + prevButton.width, ease:Expo.easeOut});				TweenLite.from(nextButton, .25, {x:nextButton.x - nextButton.width, ease:Expo.easeOut});				TweenLite.from(navButtonField, .25, {alpha:0, delay:.25});			}						// If content is audio play, start playback of top audio track			if (content is AudioDisplay)			{				AudioDisplay(content).menu.selectPlayer(0);				AudioDisplay(content).menu.players[0].autoPlay = true;			}						transitionIn();		}				private function createDescriptionText():Sprite		{			var sprite:Sprite = new Sprite();			if (contentInfo.title != "")			{				var titleField:TextField = new TextField();				titleField.autoSize = TextFieldAutoSize.LEFT;				titleField.text = contentInfo.title;				if (format.titleTextFormat.font != null) 					titleField.embedFonts = true;				titleField.setTextFormat(format.titleTextFormat);				titleField.width = content.width;				titleField.y = 4;				sprite.addChild(titleField);			}			if (contentInfo.subtitle != "")			{				var subtitleField:TextField = new TextField();				subtitleField.antiAliasType = AntiAliasType.ADVANCED;				subtitleField.autoSize = TextFieldAutoSize.LEFT;				subtitleField.text = contentInfo.subtitle;				subtitleField.y = sprite.height + 2;				if (format.subtitleTextFormat.font != null) 					subtitleField.embedFonts = true;				subtitleField.setTextFormat(format.subtitleTextFormat);				subtitleField.width = content.width;				sprite.addChild(subtitleField);			}			if (contentInfo.note != "")			{				var noteField:TextField = new TextField();				noteField.antiAliasType = AntiAliasType.ADVANCED;				noteField.autoSize = TextFieldAutoSize.LEFT;				noteField.text = contentInfo.note;				noteField.y = sprite.height + 3;				if (format.noteTextFormat.font != null) 					noteField.embedFonts = true;				noteField.setTextFormat(format.noteTextFormat);				noteField.width = content.width;				sprite.addChild(noteField);			}			return sprite;		}				private function createLinkText():TextField		{			var linkField:TextField = new TextField();			linkField.antiAliasType = AntiAliasType.ADVANCED;			linkField.autoSize = TextFieldAutoSize.LEFT;			linkField.text = contentInfo.linkText;			if (format.linkTextFormat.font != null) 				linkField.embedFonts = true;			linkField.setTextFormat(format.linkTextFormat);			linkField.width = content.width;			return linkField;		}				private function createBackground():Sprite		{			var bgr:Sprite = new RectangleShape(content.width + (format.margin*2), 												content.height + descriptionText.height + (format.margin * 2), 												format.contentBackgroundColor, 												format.contentBackgroundAlpha, 												0, 0, 0, true);			var dropShadow:BitmapFilter = new DropShadowFilter(2, 90, 0x000000, format.dropShadowAlpha, 24, 24, 1, BitmapFilterQuality.MEDIUM);			bgr.filters = [dropShadow];			return bgr;		}				private function createCloseButton():Sprite		{			var btn:Sprite = new Sprite();			var btnBgr:Sprite = new RectangleShape(format.buttonSize, format.buttonSize, format.buttonColor);			var line1:Shape = new Shape();			line1.graphics.lineStyle(3, 0xFFFFFF);			line1.graphics.lineTo(format.buttonSize/3, format.buttonSize/3);			line1.x = btnBgr.width/2 - line1.width/2 + 1;			line1.y = btnBgr.height/2 - line1.height/2 + 1;			var line2:Shape = new Shape();			line2.graphics.lineStyle(3, 0xFFFFFF);			line2.graphics.moveTo(format.buttonSize/3, 0);			line2.graphics.lineTo(0, format.buttonSize/3);			line2.x = btnBgr.width/2 - line2.width/2 + 1;			line2.y = btnBgr.height/2 - line2.height/2 + 1;			var btnShine:Sprite = new RectangleShape(format.buttonSize, format.buttonSize/2, 0xFFFFFF, .2);			btnShine.alpha = .8;			btn.addChild(btnBgr);			btn.addChild(line1);			btn.addChild(line2);			btn.addChild(btnShine);			btn.addEventListener(MouseEvent.CLICK, onCloseClick);			btn.buttonMode = true;			btn.addEventListener(MouseEvent.MOUSE_OVER, function(event:MouseEvent):void { btnShine.alpha = 1; });			btn.addEventListener(MouseEvent.MOUSE_OUT, function(event:MouseEvent):void { btnShine.alpha = .8; });			return btn;		}				/**  Sets values for next and previous buttons. **/		public function setNavIndex(cE:int, tE:int):void		{			trace("LightboxWindow.setNavIndex: "+cE+" of "+tE);			currElement = cE;			totalElements = tE;		}				private function createNavButton():Sprite		{			var btn:Sprite = new Sprite();			var btnBgr:Sprite = new EllipseShape(21, 21, format.buttonColor);			var arrowHead:Sprite = new ArrowHead(6, 12, 3, 0xFFFFFF);			arrowHead.x = btnBgr.width/2 - 1;			arrowHead.y = btnBgr.height/2 - arrowHead.height/2 + 1;			btn.addChild(btnBgr);			btn.addChild(arrowHead);			btn.buttonMode = true;			btn.alpha = .9;			btn.addEventListener(MouseEvent.MOUSE_OVER, function(event:MouseEvent):void { btn.alpha = 1; });			btn.addEventListener(MouseEvent.MOUSE_OUT, function(event:MouseEvent):void { btn.alpha = .9; });			return btn;		}			//--------------------------------------------------------------------------    //    //  Transitions    //    //--------------------------------------------------------------------------			private function transitionIn():void		{			this.visible = true;			switch (transitionStyle)			{				case TRANSITION_BUILD:						transitionInBuild();					break;									case TRANSITION_FLY_IN_RIGHT:						transitionInFlyInRight();					break;									case TRANSITION_FLY_IN_LEFT:						transitionInFlyInLeft();					break;									default:					transitionInBuild();					break;			}		}				private function transitionInBuild():void		{			closeButton.alpha = 0;			TweenLite.from(contentBackground, .5, {scaleY:.01, ease:Expo.easeInOut});			TweenLite.from(content, .25, {alpha:0, delay:.5});			TweenLite.from(descriptionText, .25, {alpha:0, delay:.5});			TweenLite.to(closeButton, 0, {alpha:1, delay:.75});			TweenLite.from(closeButton, .25, {y:closeButton.y + closeButton.height, ease:Expo.easeOut, delay:.75, overwrite:false, onComplete:transitionInComplete});		}				private function transitionInFlyInRight():void		{			TweenLite.from(this, .5, {alpha:0, x:this.x + this.width, ease:Expo.easeOut, onComplete:transitionInComplete});		}				private function transitionInFlyInLeft():void		{			TweenLite.from(this, .5, {alpha:0, x:this.x - this.width, ease:Expo.easeOut, onComplete:transitionInComplete});		}				private function transitionInComplete():void		{			dispatchEvent(new Event(Event.COMPLETE));		}				public function transitionOut():void		{			trace("LightboxWindow.transitionOut");			switch (transitionStyle)			{				case TRANSITION_BUILD:					{					transitionOutBuild();					break;				}								case TRANSITION_FLY_IN_RIGHT:					{					transitionOutFlyInRight();					break;				}								case TRANSITION_FLY_IN_LEFT:					{					transitionOutFlyInLeft();					break;				}								default:				{					transitionOutBuild();					break;				}			}		}				private function transitionOutBuild():void		{			if (content)				TweenLite.to(content, .25, {alpha:0});			if (descriptionText)				TweenLite.to(descriptionText, .25, {alpha:0});			if (closeButton)				TweenLite.to(closeButton, .25, {y:closeButton.y + closeButton.height*2, alpha:0, ease:Expo.easeIn});			if (prevButton)  				TweenLite.to(prevButton, .25, {alpha:0});			if (nextButton)  				TweenLite.to(nextButton, .25, {alpha:0});			if (contentBackground)				TweenLite.to(contentBackground, .25, {scaleY:.01, delay:.1, ease:Expo.easeIn, onComplete:transitionOutComplete});		}				private function transitionOutFlyInRight():void		{			TweenLite.to(this, .25, {alpha:0, x:this.x - this.width, ease:Expo.easeIn, onComplete:transitionOutComplete});		}				private function transitionOutFlyInLeft():void		{			TweenLite.to(this, .25, {alpha:0, x:this.x + this.width, ease:Expo.easeIn, onComplete:transitionOutComplete});		}				private function transitionOutComplete():void		{			if (parent) 				parent.removeChild(this);		}			//--------------------------------------------------------------------------    //    //  Event Handlers    //    //--------------------------------------------------------------------------				private function onNextClick(event:MouseEvent):void		{			dispatchEvent(new Event(LIGHTBOX_NEXT));		}				private function onPrevClick(event:MouseEvent):void		{			dispatchEvent(new Event(LIGHTBOX_PREV));		}				private function onContentLoadComplete(event:Event):void		{			if (content.width > 0)				build();			else				onIOError(new IOErrorEvent(IOErrorEvent.IO_ERROR));		}				private function onCloseClick(event:Event):void		{			dispatchEvent(new Event(Event.CLOSE));		}				private function onIOError(event:IOErrorEvent):void		{			trace("LightboxWindow Content not found at "+contentInfo.url);			this.visible = false;			dispatchEvent(event);		}	}}