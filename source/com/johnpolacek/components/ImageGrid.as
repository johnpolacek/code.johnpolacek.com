package com.johnpolacek.components {		import flash.display.Sprite;	import flash.events.Event;	import flash.events.IOErrorEvent;	import com.greensock.TweenLite;	import com.johnpolacek.display.ImageDisplay;	/** * Loads and arranges images in a grid * <i>NOTE: Images should be uniform in size.</i> * * @example  * <br /> * Create grid 4 images wide (images should be same size) * <code> * var grid:ImageGrid = new ImageGrid(4); * </code> *  * create grid 4 images wide x 3 images high * <code> * var grid:ImageGrid = new ImageGrid(4, 3); * </code> *  * create 4x3 grid, with 10 pixels spacing * <code> * var grid:ImageGrid = new ImageGrid(4, 3, 10); * </code> *  * create array of image url's * <code> * var images = ["img/image1.jpg","img/image2.jpg"...]; // array of image url's * grid.loadImages(images); * </code> *  * @see com.johnpolacek.display.ImageDisplay * @version 7 Mar 2010 * @author John Polacek, john@johnpolacek.com */		public class ImageGrid extends Sprite {						/**  Width of grid (i.e. 4 images wide) **/		public var gridWidth:int;		/**  Height of grid (i.e. 4 images wide) **/		public var gridHeight:int;		/**  Spacing between images (in pixels) **/		public var spacing:int;		/**  Multidimensional array of images divided into rows **/		public var rows = [];		/**  Multidimensional array of images divided into columns **/		public var cols = [];		/**  Tracks horizontal positioning during image loading **/		public var xCount:int = 0;		/**  Tracks vertical positioning during image loading **/		public var yCount:int = 0;		/**  Array of image url's being loaded **/		public var urlsToLoad = [];		/**  Number of images loaded **/		public var imagesLoaded:int = 0;		/**  Total number of images for the grid **/		public var totalImages:int = 0;		/**  Duration of fade transition in when images are loaded. Default is 0 (no transition). **/		public var transitionDuration:Number = 0;		/**  If true, grid is aligned to the center **/		public var alignCenter:Boolean = false;				private var alignX:int = 0;		private var alignY:int = 0;		private var imageX:int = 0;		private var imageY:int = 0;				/** 		* @param w Sets grid width (number of images wide)		* @param h Sets grid height (number of images tall)		* @param s Sets grid spacing between sprites in pixels (default is 0)		*/			public function ImageGrid(w:int, h:int = 0, s:int = 0) 		{			gridWidth = w;			gridHeight = h;			spacing = s;			if (gridWidth == 0)				gridWidth = 999;			if (h == 0)				gridHeight = 999;						rows[0] = [];			cols[0] = [];		}				/** Loads multiple images into the grid	 	* 		* @param urls Array of image URL strings to load		*/			public function loadImages(urls:Array):void		{			urlsToLoad = urls;			totalImages += urls.length;			loadImage(urls[0]);		}				/** Loads a single image into the grid	 	* 		* @param url Image URL string to load		*/			public function loadImage(url:String):void		{			totalImages++;			var	image:ImageDisplay = new ImageDisplay(url);			image.addEventListener(IOErrorEvent.IO_ERROR, onIOError);			image.addEventListener(Event.COMPLETE, onImageLoadComplete);		}				/** Adds a sprite into the grid (at the last position)	 	* 		* @param url Image URL string to load		*/			public function addImage(image:Sprite):void		{			// if first image being added, set alignment			if (this.numChildren == 0 && alignCenter)			{				if (gridWidth != 999)					alignX = imageX = -((image.width * gridWidth)+(spacing * (gridWidth-1)))/2;				if (gridHeight != 999)					alignY = imageY = -((image.height * gridHeight)+(spacing * (gridHeight-1)))/2;			}						image.x = imageX;			image.y = imageY;			addChild(image);			if (transitionDuration > 0)				TweenLite.from(image, transitionDuration, {alpha:0});						// insert image into rows and cols			if (rows[yCount] == undefined)				rows[yCount] = [];			rows[yCount][xCount] = image;			if (cols[xCount] == undefined)				cols[xCount] = [];			cols[xCount][yCount] = image;							// set positioning variables for next image			xCount++;			if (xCount == gridWidth)			{				// new row				xCount = 0;				imageX = alignX;				imageY += image.height + spacing;				yCount++;			}			else			{				imageX += image.width + spacing;			}						if (yCount == gridHeight)				totalImages = this.numChildren;						if (this.numChildren == totalImages) 				dispatchEvent(new Event(Event.COMPLETE));		}					/** IOError handler */			public function onIOError(event:IOErrorEvent):void		{			trace("Image not found. Will not be added to grid");			event.target.addEventListener(IOErrorEvent.IO_ERROR, onIOError);			event.target.addEventListener(Event.COMPLETE, onImageLoadComplete);						totalImages--;			if (this.numChildren == totalImages) 			{				if (totalImages == 0)					dispatchEvent(event);				else					dispatchEvent(new Event(Event.COMPLETE));			}		}				/** Image load complete handler */			public function onImageLoadComplete(event:Event):void		{			event.target.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);			event.target.removeEventListener(Event.COMPLETE, onImageLoadComplete);			addImage(Sprite(event.target));			imagesLoaded++;			if (imagesLoaded < urlsToLoad.length && yCount < gridHeight)				loadImage(urlsToLoad[imagesLoaded]);			else				urlsToLoad = [];		}	}}