package com.johnpolacek.ui {		import flash.display.Sprite;	import flash.events.MouseEvent;	import com.greensock.TweenLite;	import com.johnpolacek.shapes.RectangleShape;	import com.johnpolacek.events.UIEvent;	import com.johnpolacek.ui.BasicButton	/** * The BasicButtonMenu class is for creating simple button menu navigation. * * @example  * <br /> * Create a BasicButtonMenu with 5 buttons: * <code> * var menu:BasicButtonMenu = new BasicButtonMenu(); * for (i = 0; i < 5; i++) * { *    var menuButton:Sprite = new Sprite(); * 	  var menuButtonText:TextField = new TextField(); * 	  menuButtonText.text = "Button #"+(i+1); * 	  menuButton.addChild(menuButtonText); * 	  menu.addButton(menuButton); * }; * menu.addEventListener(UIEvent.BUTTON_SELECT, onButtonSelect); * function onButtonSelect(event:UIEvent):void * { *    trace("Menu Button Index: "+event.value);  * } * </code> *  * @version  * <b>08 Apr 2010</b>  Fixed issue with button spacing <br>  * <b>05 Apr 2010</b>  * @author John Polacek, john@johnpolacek.com */	 	public class BasicButtonMenu extends Sprite 	{				/** Array of buttons in the menu. **/		public var buttons:Array = [];		/** Base alpha of buttons in the menu. **/		public var buttonAlpha:Number = .9;		/** Rollover alpha of buttons in the menu. Default .9 **/		public var rolloverAlpha:Number = 1;		/** Rollover color of buttons in the menu. Default null (none) **/		public var rolloverColor:String;		/** Select color of buttons in the menu. Default null (none) **/		public var selectColor:String;		/** Sets the spacing in pixels between buttons. Default 1 **/		public var spacing:int = 0;		/** Sets alignment. If true, buttons are stacked vertically. **/		public var isVertical:Boolean = true;		/** Index of current button selected **/		public var currButtonIndex:int = -1;		/** Determines if button select event bubbles **/		public var bubbles:Boolean = true;		/** Optional background shape **/		public var background:Sprite;		/** If true, selected button maintains its rollover state when selected **/		public var showButtonSelection:Boolean = true;		/** Optional graphic that appears next to selected menu button **/		public var buttonSelectGraphic:Sprite;				private var buttonPosition:int = 0;		private var buttonSelectTransition:Function;		/** @param ba Alpha of button when not selected. Default .9*/		public function BasicButtonMenu(ba:Number = .9) 		{			buttonAlpha = ba;		}				/** 		* @param sprite Sprite to be used by the BasicButton instance		* @param val Optional string value contained by the BasicButton that can be used in event handling. Default ""		* @param enableSimpleRollovers If true, button's alpha value will respond to MOUSE_OVER. Default true		* @param ba Base alpha of button. Default .9		* @param ba Alpha of button on MOUSE_OVER if enableSimpleRollovers set to true. Default 1		*/		public function addButton(sprite:Sprite, val:String = "", ba:Number = -1):void		{			if (ba == -1)				ba = buttonAlpha;			var enableSimpleRollovers:Boolean = (ba != rolloverAlpha || rolloverColor);			var button:BasicButton = new BasicButton(val, enableSimpleRollovers, ba, rolloverAlpha, rolloverColor, rolloverColor);			sprite.mouseChildren = false;			button.addChild(sprite);			if (isVertical)			{				button.y = buttonPosition;				buttonPosition += button.height + spacing;			}			else			{				button.x = buttonPosition;				buttonPosition += button.width + spacing;			}						sprite.addEventListener(MouseEvent.MOUSE_DOWN, onClick);			buttons.push(button);			addChild(button);		}				public function addButtonSelectGraphic(graphic:Sprite, graphicX:int = 0, graphicY:int = 0, transitionIn:Function = null):void		{			buttonSelectGraphic = graphic;			buttonSelectGraphic.x = -buttonSelectGraphic.width + graphicX;			buttonSelectGraphic.y = graphicY;			if (transitionIn != null)				buttonSelectTransition = transitionIn;			updateGraphic();		}				public function hideButtons():void		{			for each (var button:BasicButton in buttons) 			{				button.alpha = 0;			}		}				public function showButton(i:int):void		{			TweenLite.to(buttons[i], 1, {alpha:1});		}				public function updateGraphic():void		{			if (currButtonIndex != -1)			{				buttons[currButtonIndex].addChildAt(buttonSelectGraphic, 0);				if (buttonSelectTransition != null)					buttonSelectTransition(buttonSelectGraphic);				else					TweenLite.from(buttonSelectGraphic, .25, {alpha:0, overwrite:false});			}			else			{				if (buttonSelectGraphic.parent)					buttonSelectGraphic.parent.removeChild(buttonSelectGraphic);			}		}				/** Button onClick handler */		public function onClick(event:MouseEvent):void		{			currButtonIndex = buttons.indexOf(event.currentTarget.parent);			dispatchEvent(new UIEvent(UIEvent.BUTTON_SELECT, currButtonIndex, bubbles));			selectButton(currButtonIndex);		}				/** Selects the active button for the menu, as if clicked, but does not trigger event) */		public function selectButton(buttonIndex:int):void		{			currButtonIndex = buttonIndex;			if (showButtonSelection)			{				for (var i:int = 0; i < buttons.length; i++)				{					buttons[i].select(buttonIndex == i);				}				if (buttonSelectGraphic)					updateGraphic();			}		}				public function addBackground(backgroundColor:uint, backgroundAlpha:Number, margin:int = 20):void		{			background = new RectangleShape(this.width + margin, this.height + margin, backgroundColor, backgroundAlpha);			addChildAt(background, 0);			for each (var button:BasicButton in buttons)			{				button.x += margin/2;				button.y += margin/2;			}		}	}}