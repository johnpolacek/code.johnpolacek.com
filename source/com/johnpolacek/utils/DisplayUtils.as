package com.johnpolacek.utils {		import flash.display.Sprite;	import flash.display.Shape;	import flash.display.LineScaleMode;	import flash.display.CapsStyle;	import flash.display.JointStyle;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.net.URLRequest;	import flash.net.navigateToURL;	import flash.text.Font;	import flash.utils.Timer;				/** * Utilities for Display Objects * * @author John Polacek, john@johnpolacek.com */		public class DisplayUtils {				/** Removes all children of target sprite. */			public static function removeAllChildren(container:Sprite):void		{			if (container.numChildren!=0)			{				var i:int = container.numChildren;				while(i--)				{					container.removeChildAt(i);				}			}		}				/** Sets visible property to false for all children of target sprite. */			public static function hideAllChildren(container:Sprite):void		{			var n:int = container.numChildren;			for (var i:int = 0; i < n; i++)	        {				container.getChildAt(i).visible = false;			}		}				/** Scales target sprite to fit within a given width/height */			public static function scaleToFit(target:Sprite, scaleWidth:Number, scaleHeight:Number):void		{			target.width = scaleWidth;			target.height = scaleHeight;			if (target.scaleX < target.scaleY) 				target.scaleY = target.scaleX;			else 				target.scaleX = target.scaleY;		}				/** Scales target sprite to fill a given width/height */			public static function scaleToFill(target:Sprite, scaleWidth:Number, scaleHeight:Number):void		{			target.width = scaleWidth;			target.height = scaleHeight;			if (target.scaleX < target.scaleY) 				target.scaleY = target.scaleX;			else 				target.scaleX = target.scaleY;		}				/** Adds rectangle outline to the top level of a target sprite sized to its width/height */		public static function addOutline(target:Sprite, outlineColor = 0x000000, outlineAlpha = .5):void		{			var outline:Shape = new Shape;			outline.graphics.lineStyle(0, outlineColor, outlineAlpha, false, LineScaleMode.NONE, CapsStyle.NONE, JointStyle.MITER, 10);			outline.graphics.drawRect(0,0,target.width,target.height);			target.addChild(outline);		}				/** Adds hyperlink to target sprite */		public static function addLink(target:Sprite, url:String, window:String = "_blank") 		{			if (window != "_blank" && window!= "_self") 				window = "_blank";			target.addEventListener(MouseEvent.CLICK, function():void { navigateToURL(new URLRequest(url), "_blank"); } );			target.buttonMode = true;					}				/** Adds rectangle shape to bottom level target sprite */		public static function addBackgroundShapeBehind(target:Sprite, backgroundColor = 0x000000, backgroundAlpha = 1):void		{			var background:Shape = new Shape;			background.graphics.beginFill(backgroundColor, backgroundAlpha);			background.graphics.drawRect(0, 0, target.width, target.height);			background.x = target.x;			background.y = target.y;			target.parent.addChild(background);			target.parent.swapChildren(background, target);		}				/** Creates a trace output of the names of all fonts embedded at runtime */		public static function traceRuntimeFonts():void		{			var embeddedFonts:Array = Font.enumerateFonts(false);			embeddedFonts.sortOn("fontName", Array.CASEINSENSITIVE);			for each (var font:Font in embeddedFonts) 			{				trace("Embedded Font: "+font.fontName);			}		}				/** Creates a trace output of the names of all fonts embedded at runtime */		public static function getRuntimeFonts():Array		{			var embeddedFonts:Array = Font.enumerateFonts(false);			embeddedFonts.sortOn("fontName", Array.CASEINSENSITIVE);			var fontNames = [];			for each (var font:Font in embeddedFonts) 			{				fontNames.push(font.fontName);			}			return fontNames;		}				/** Corrects color codes to flash uintConverts #000000 to 0x000000 */		public static function getColorCodeFromString(colorString:String) :uint		{			// Credit to Glenn Gervais/rabidGadfly.com for fixColorCode method on which this is based			var validColor:String;			var pattern:RegExp = /#/;			colorString = colorString.replace(pattern,"");			pattern = /0x/;			if (colorString.substring(0,2) != "0x")				validColor = "0x"+colorString;			else				validColor = colorString;			return uint(validColor);		}	}}